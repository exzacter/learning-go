# REST API - Go Learning Project

A REST API built with Go's standard library to learn web development fundamentals, database integration, and API design patterns.

## Overview

This project is a learning-focused REST API that demonstrates:
- Building HTTP servers with Go's standard library (`net/http`)
- PostgreSQL database integration
- Type-safe SQL queries using `sqlc`
- Password hashing and security best practices
- Clean architecture with separation of concerns
- Environment-based configuration

## Project Structure

```
rest-api/
├── main.go                          # Application entry point
├── serverconfig/                    # Server configuration
│   └── config.go                    # Environment variable loading
├── dbconfig/                        # Database configuration
│   └── dbconfig.go                  # PostgreSQL connection setup
├── internal/
│   ├── handlers/                    # HTTP request handlers
│   │   ├── core_handler.go         # Core handler struct (holds DB & queries)
│   │   ├── health.go               # Health check endpoint
│   │   ├── test.go                 # Test endpoint
│   │   └── user.go                 # User registration handler
│   ├── routes/                      # Route definitions
│   │   ├── setup_routes.go         # Main route setup
│   │   ├── health_routes.go        # Health route registration
│   │   ├── test_routes.go          # Test route registration
│   │   └── user_rotues.go          # User route registration
│   ├── store/                       # Database layer (sqlc generated)
│   │   ├── db.go                   # Database interface & queries
│   │   ├── models.go               # Database models
│   │   └── queries.sql.go          # Generated SQL queries
│   ├── dtos/                        # Data Transfer Objects
│   │   └── request.go              # Request structures
│   ├── utils/                       # Utility functions
│   │   ├── passwordutil.go         # Password hashing & comparison
│   │   ├── errorresponse.go        # Standardized error responses
│   │   └── successresponse.go      # Standardized success responses
│   └── migrations/                  # Database migrations
│       ├── schema.sql               # Database schema (users & blogs tables)
│       └── queries.sql              # SQL queries for sqlc
└── models/                          # Domain models
    ├── user.go
    └── blog.go
```

## How Components Connect

### 1. Application Startup (`main.go`)
```
LoadConfig() → ConnectDB() → NewHandlers() → SetupRoutes() → Start Server
```

**Flow:**
1. **Configuration Loading**: `serverconfig.LoadConfig()` reads environment variables from `.env` file
   - Loads: `SERVER_PORT`, `DATABASE_URL`, `ENVIRONMENT`, `LOG_LEVEL`
   - Falls back to defaults if variables aren't set

2. **Database Connection**: `dbconfig.ConnectDB()` establishes PostgreSQL connection
   - Uses connection string from config
   - Verifies connection with `db.Ping()`

3. **Query Initialization**: `store.New(db)` creates type-safe query interface
   - Generated by `sqlc` from SQL files
   - Provides methods like `CreateUser()`, `GetUser()`, etc.

4. **Handler Setup**: `handlers.NewHandlers()` creates handler struct
   - Holds database connection and queries
   - All handlers are methods on this struct

5. **Router Setup**: `http.NewServeMux()` creates the router
   - Maps URL paths to handler functions
   - `routes.SetupRoutes()` registers all endpoints

6. **Server Start**: `http.Server` starts listening on configured port
   - All requests pass through the `mux` router
   - Router dispatches to appropriate handlers

### 2. Request Flow

```
Client Request → Router (mux) → Route Handler → Business Logic → Database → Response
```

**Example: User Registration**
1. Client sends `POST /user/register` with JSON body
2. Router matches path and calls `handler.CreateUserHandler()`
3. Handler:
   - Decodes JSON request into `CreateUserRequest` DTO
   - Hashes password using `utils.HashPassword()`
   - Calls `h.Queries.CreateUser()` to insert into database
   - Returns standardized JSON response using `utils.RespondWithSuccess()` or `utils.RespondWithError()`

### 3. Database Layer (sqlc)

The project uses **sqlc** to generate type-safe Go code from SQL:

1. **Schema Definition** (`schema.sql`): Defines database tables
2. **Query Definition** (`queries.sql`): SQL queries with named parameters
3. **Code Generation** (`sqlc.yaml`): Configuration for sqlc
4. **Generated Code** (`internal/store/`): Type-safe Go functions

Benefits:
- Compile-time SQL validation
- No ORM overhead
- Full SQL control
- Type safety

## Current Features

### Endpoints

| Method | Path | Description |
|--------|------|-------------|
| GET | `/health` | Health check - returns server status |
| GET | `/test` | Test endpoint - verifies routing works |
| POST | `/user/register` | Create new user with hashed password |

### Implemented Functionality

- **User Registration**: Creates users with bcrypt-hashed passwords
- **Database Integration**: PostgreSQL with sqlc-generated queries
- **Error Handling**: Standardized JSON error responses
- **Configuration Management**: Environment-based config with `.env` file
- **Password Security**: Bcrypt hashing with default cost factor

### Database Schema

**Users Table:**
- `id` (Serial Primary Key)
- `username` (VARCHAR)
- `email` (VARCHAR)
- `password` (VARCHAR - hashed)
- `created` (TIMESTAMP)
- `updated` (TIMESTAMP)

**Blogs Table** (schema exists, not yet implemented):
- `id` (Serial Primary Key)
- `title` (VARCHAR)
- `content` (VARCHAR)
- `user_id` (Foreign Key to users)
- `created` (TIMESTAMP)
- `updated` (TIMESTAMP)

## Setup & Running

### Prerequisites
- Go 1.21+
- PostgreSQL
- sqlc (for regenerating queries)

### Environment Variables
Create a `.env` file in the `rest-api/` directory:
```env
SERVER_PORT=8080
DATABASE_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable
ENVIRONMENT=development
LOG_LEVEL=info
```

### Running the Server
```bash
cd rest-api
go run main.go
```

Server will start on the configured port (default: `:8080`)

### Testing Endpoints

**Health Check:**
```bash
curl http://localhost:8080/health
```

**User Registration:**
```bash
curl -X POST http://localhost:8080/user/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "email": "test@example.com",
    "password": "securepassword"
  }'
```

## Learning Notes

### Key Concepts Demonstrated

1. **HTTP Router (ServeMux)**: Maps URL paths to handler functions
2. **Handler Pattern**: Functions that return `http.HandlerFunc` for closure over dependencies
3. **Context Usage**: Request context passed to database queries
4. **JSON Encoding/Decoding**: `json.NewEncoder()` and `json.NewDecoder()`
5. **Dependency Injection**: Handler struct holds DB and queries
6. **Password Security**: Never store plain text passwords
7. **Error Handling**: Proper HTTP status codes and error messages

## TODO List

### Authentication & Security
- [ ] Implement user login endpoint
- [ ] Add JWT token generation and validation
- [ ] Create authentication middleware
- [ ] Add refresh token functionality
- [ ] Implement password reset flow
- [ ] Add email verification
- [ ] Rate limiting to prevent brute force attacks
- [ ] Add CORS middleware for cross-origin requests

### User Management
- [ ] Get user profile endpoint (GET `/user/:id`)
- [ ] Update user profile endpoint (PUT `/user/:id`)
- [ ] Delete user endpoint (DELETE `/user/:id`)
- [ ] List users with pagination (GET `/users?page=1&limit=10`)
- [ ] User search functionality
- [ ] Change password endpoint

### Blog Functionality
- [ ] Create blog post endpoint (POST `/blogs`)
- [ ] Get single blog post (GET `/blogs/:id`)
- [ ] List all blog posts with pagination (GET `/blogs`)
- [ ] Update blog post (PUT `/blogs/:id`)
- [ ] Delete blog post (DELETE `/blogs/:id`)
- [ ] Get blogs by user (GET `/users/:id/blogs`)
- [ ] Add blog categories/tags
- [ ] Blog search functionality
- [ ] Blog comments feature

### Validation & Error Handling
- [ ] Add request validation middleware
- [ ] Validate email format
- [ ] Validate password strength requirements
- [ ] Add custom validation errors with field details
- [ ] Centralized error logging
- [ ] Better database error handling (unique constraint violations, etc.)

### Middleware
- [ ] Request logging middleware (log all requests)
- [ ] Recovery middleware (panic recovery)
- [ ] Request ID middleware for tracing
- [ ] Response time tracking
- [ ] Content-Type validation

### Database & Queries
- [ ] Add database migrations tool (like golang-migrate)
- [ ] Implement soft deletes for users and blogs
- [ ] Add database indexes for performance
- [ ] Implement database transactions for complex operations
- [ ] Add prepared statements caching
- [ ] Connection pool optimization

### Testing
- [ ] Unit tests for handlers
- [ ] Unit tests for utilities (password hashing, etc.)
- [ ] Integration tests for API endpoints
- [ ] Mock database for testing
- [ ] Test coverage reporting
- [ ] Load testing / benchmarks

### Documentation
- [ ] Add API documentation (Swagger/OpenAPI)
- [ ] Document all environment variables
- [ ] Add example requests/responses for all endpoints
- [ ] Create Postman collection
- [ ] Add architecture diagrams

### Code Quality
- [ ] Add linting configuration (golangci-lint)
- [ ] Set up CI/CD pipeline
- [ ] Add pre-commit hooks
- [ ] Improve error messages for debugging
- [ ] Add structured logging (replace fmt.Println)
- [ ] Add health check for database connectivity

### Performance & Scalability
- [ ] Implement caching (Redis)
- [ ] Add database query optimization
- [ ] Implement pagination helpers
- [ ] Add response compression
- [ ] Query result caching

### DevOps & Deployment
- [ ] Create Dockerfile
- [ ] Docker Compose for local development
- [ ] Add health check endpoint improvements (DB status, memory, etc.)
- [ ] Environment-specific configurations (dev, staging, prod)
- [ ] Add graceful shutdown handling

### Advanced Features
- [ ] File upload for user avatars
- [ ] File upload for blog images
- [ ] Email service integration
- [ ] WebSocket support for real-time features
- [ ] API versioning strategy (v1, v2)
- [ ] Admin panel endpoints
- [ ] Role-based access control (RBAC)
- [ ] OAuth integration (Google, GitHub login)

## Technologies Used

- **Language**: Go
- **Database**: PostgreSQL
- **SQL Generator**: sqlc
- **Password Hashing**: bcrypt
- **Environment Config**: godotenv
- **HTTP**: Standard library (`net/http`)

## Learning Resources

This project demonstrates common patterns in Go web development. Key learning areas:
- RESTful API design
- Database integration without ORMs
- Secure password handling
- Clean code architecture
- Go standard library HTTP server
