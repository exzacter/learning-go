# Domain Models

This package contains domain models used in the application layer.

## Files

- `user.go` - User domain model
- `blog.go` - Blog domain model

## Purpose

These models represent business entities at the application level, separate from:
- **Database models** (`internal/store/models.go`) - Generated by sqlc
- **DTOs** (`internal/dtos/`) - Request/response structures

## User Model (`user.go`)

```go
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
    Password string `json:"password"`
    Created  string `json:"created"`
    Updated  string `json:"updated"`
}
```

**Field Types**:
- Uses simple Go types (`int`, `string`)
- Timestamps are `string` instead of `sql.NullTime`

---

## Blog Model (`blog.go`)

```go
type Blog struct {
    ID      int    `json:"id"`
    Title   string `json:"title"`
    Content string `json:"content"`
    UserID  int    `json:"user_id"`
    Created string `json:"created"`
    Updated string `json:"updated"`
}
```

**Relationship**: `UserID` links blog to user

---

## Domain vs Database vs DTO Models

### Comparison Table

| Aspect | Domain Model | Database Model | DTO |
|--------|-------------|----------------|-----|
| **Location** | `models/` | `internal/store/` | `internal/dtos/` |
| **Purpose** | Business logic | Database operations | API contracts |
| **Types** | Simple (`int`, `string`) | Database types (`int32`, `sql.NullTime`) | Simple (`string`) |
| **Generated** | ❌ Manual | ✅ sqlc | ❌ Manual |
| **JSON Tags** | ✅ Yes | ✅ Yes | ✅ Yes |

### When to Use Each

**Database Models** (`store.User`):
- Direct database interactions
- sqlc-generated queries
- Type-safe SQL operations

**Domain Models** (`models.User`):
- Business logic layer
- Application services
- Not currently used (prepared for future use)

**DTOs** (`dtos.CreateUserRequest`):
- API request/response
- Client communication
- Validation layer

## Current Status

**Not actively used yet** - These models are prepared for when you add a service/business logic layer between handlers and database.

### Future Use Case Example

When you add business logic:

```go
// Service layer (future)
type UserService struct {
    queries *store.Queries
}

func (s *UserService) GetUser(id int) (*models.User, error) {
    // Get from database
    dbUser, err := s.queries.GetUser(ctx, int32(id))

    // Convert database model to domain model
    return &models.User{
        ID:       int(dbUser.ID),
        Username: dbUser.Username,
        Email:    dbUser.Email,
        Created:  dbUser.Created.Time.String(),
        Updated:  dbUser.Updated.Time.String(),
    }, nil
}
```

## Key Learning Points

1. **Layered Architecture**: Separate models for different layers
2. **Type Conversion**: Domain models use simpler types than database models
3. **Future Proofing**: Prepared for business logic layer
4. **Clean Architecture**: Domain models independent of database implementation
5. **Not Always Needed**: Small projects can work directly with database models

## Current Architecture (Simplified)

```
HTTP Request
  └─> DTO (dtos.CreateUserRequest)
        └─> Handler processes
              └─> Database Model (store.CreateUserParams)
                    └─> Database
```

## Future Architecture (With Domain Models)

```
HTTP Request
  └─> DTO (dtos.CreateUserRequest)
        └─> Service Layer
              └─> Domain Model (models.User)
                    └─> Repository/Store
                          └─> Database Model (store.User)
                                └─> Database
```

When your application grows and needs business logic, you'll convert between these layers.
